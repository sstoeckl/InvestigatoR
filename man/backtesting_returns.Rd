% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/backtesting_returns.R
\name{backtesting_returns}
\alias{backtesting_returns}
\title{Backtesting Returns Function}
\usage{
backtesting_returns(
  data,
  return_prediction_object = NULL,
  return_label,
  features,
  rolling = TRUE,
  window_size,
  step_size = "1 month",
  offset = "0 months",
  in_sample = TRUE,
  ml_config,
  append = FALSE,
  num_cores = NULL,
  verbose = TRUE,
  seed = 123
)
}
\arguments{
\item{data}{ML dataset (tibble/data.frame) in long format that should contain the features and the \code{return_label} as well as the \code{stock_ids} (first column) and
dates (second column). For most ML algorithms to work, this dataset should not contain missing values. Sometimes it needs
to be balanced in terms of the number of stocks available at each point in time.}

\item{return_prediction_object}{An object of class \code{returnPrediction} that should be used to store the predictions. Default (\code{NULL}) creates a new one.
In case an existing object is passed, given \code{append = TRUE}, new predictions are added. If \code{append = FALSE}, the object is overwritten.}

\item{return_label}{The prediction label that should be used for the ML model. It should already be appropriately shifted (and date the label should be from date \code{t+1}).}

\item{features}{A vector of features that should be used for the ML model.}

\item{rolling}{If \code{TRUE}, the function will use a rolling window approach to predict the returns. If \code{FALSE}, the function will use an expanding window approach.}

\item{window_size}{(Either in number of time steps or in years or months as \code{"1 year"} or \code{"1 month"}) The size of the window that should be used for the
rolling window approach. If \code{rolling = FALSE}, this is the starting window for the expanding window approach.}

\item{step_size}{The amount of time the prediction window should be moved forward. Default is \code{"1 month"}. If set to \code{"3 months"}, returns will be predicted for \code{t}, \code{t+1}, and \code{t+2}
(corresponding to \code{t+1}, \code{t+2}, and \code{t+3}) in the original dataset. Only then will the ML model be retrained.}

\item{offset}{(Either in number of time steps or in years or months as \code{"1 year"} or \code{"1 month"}) The size of data that should be left unused between training data
and prediction (to avoid look-ahead bias). Default is \code{"0 months"}.}

\item{in_sample}{If \code{TRUE}, the function will also provide (in-sample) predictions for the training period (plus offset).}

\item{ml_config}{A list that contains the configuration for the ML models. It should contain the following elements:}

\item{append}{If \code{TRUE}, the function will append the predicted returns to the original dataset. If \code{FALSE}, the function will return a new dataset that contains the
predicted returns.}

\item{num_cores}{The number of cores that should be used for parallel processing. If set to \code{NULL}, the ML iterations will be done sequentially.}

\item{verbose}{If \code{TRUE}, detailed messages will be printed. Default is \code{TRUE}.}

\item{seed}{integer. Seed for random number generation}
}
\value{
An S3 object of class \code{returnPrediction} that contains all the information associated with the backtesting results. It includes information on the used models (\code{rp$models}), the predictions (\code{rp$predictions}), the actual returns (\code{rp$actual_returns}), and the errors (\code{rp$errors}).
}
\description{
This function uses machine learning models to predict returns that will later be used for a trading strategy.
}
\examples{
\dontrun{
data(data_ml)
return_label <- "R1M_Usd"
features <- c("Div_Yld", "Eps", "Mkt_Cap_12M_Usd", "Mom_11M_Usd", "Ocf", "Pb", "Vol1Y_Usd")
rolling <- FALSE
window_size <- "5 years"
step_size <- "1 month"
offset <- "1 month"
in_sample <- TRUE
ml_config <- list(
  ols_pred = list(pred_func = "ols_pred", config = list()),
  xgb_pred = list(
    pred_func = "xgb_pred",
    config1 = list(nrounds = 10, max_depth = 3, eta = 0.3, objective = "reg:squarederror"),
    config2 = list(nrounds = 10, max_depth = 3, eta = 0.1, objective = "reg:squarederror")
  )
)
rp <- backtesting_returns(
  data = data_ml,
  return_prediction_object = NULL,
  return_label = return_label,
  features = features,
  rolling = rolling,
  window_size = window_size,
  step_size = step_size,
  offset = offset,
  in_sample = in_sample,
  ml_config = ml_config,
  append = FALSE,
  num_cores = NULL,
  verbose = TRUE
)
}
}
